import 'dart:io';

import 'package:args/command_runner.dart';
import 'package:cli/src/constant.dart';
import 'package:cli/src/utils/color.dart';
import 'package:cli/src/utils/melos.dart';
import 'package:cli/src/utils/path.dart';
import 'package:mason_logger/mason_logger.dart';
import 'package:path/path.dart';
import 'package:yaml/yaml.dart';
import 'package:yaml_edit/yaml_edit.dart';

/// {@template sample_command}
///
/// `cli sample`
/// A [Command] to exemplify a sub command
/// {@endtemplate}
final class LabelsCommand extends Command<int> {
  /// {@macro sample_command}
  LabelsCommand({
    required Logger logger,
  }) : _logger = logger {
    argParser.addFlag(
      'cyan',
      abbr: 'c',
      help: 'Prints the same joke, but in cyan',
      negatable: false,
    );
  }

  @override
  String get description => 'A sample sub command that just prints one joke';

  @override
  String get name => 'labels';

  final Logger _logger;

  @override
  Future<int> run() async {
    final rootDir = await executeGitRevParse(
      onFailure: () => _logger.err('Failed to get root directory.'),
    );
    _logger.info('rootDir: $rootDir');

    final labelsFile = File(join(rootDir, '.github', 'labels.yml'));
    if (!labelsFile.existsSync()) {
      _logger.err('Required files not found.');
      exit(ExitCode.noInput.code);
    }

    final melosPackageList = await executeMelosPackageListProcess(
      onFailure: () => _logger.err('Failed to get package list.'),
    );

    // 自動生成の区切り行を探す
    final labelsContentLines = await labelsFile.readAsLines();
    final autoGeneratedIndex = labelsContentLines.indexWhere(
      (line) => line.contains(autoGeneratedLabelComment),
    );
    if (autoGeneratedIndex == -1) {
      _logger.err('Auto-generated label section not found.');
      exit(1);
    }

    // 自動生成より前のテキストのみ取得する
    final preGeneratedContent = labelsContentLines
        .sublist(
          0,
          autoGeneratedIndex,
        )
        .join('\n');
    // 自動生成以降のテキストを取得する
    final generatedContent = labelsContentLines.sublist(autoGeneratedIndex);

    final labelsYaml = loadYaml(generatedContent.join('\n')) as YamlList;
    final generatedLabels = <Map<String, String>>[];
    for (final package in melosPackageList) {
      final name = package.location.replaceAll('$rootDir/', '');
      final labelName = '@$name';
      final existingLabel = labelsYaml.firstWhere(
        (label) => (label as YamlMap)['name'] == labelName,
        orElse: () => null,
      );

      final existingDescription = existingLabel?['description'];
      final newLabel = <String, String>{
        'name': labelName,
        'color': existingLabel?['color'].toString() ?? generateRandomColor(),
        'description': existingDescription?.toString() ??
            '${name.replaceAll('/', ' ')} package',
      };

      generatedLabels.add(newLabel);
    }

    // auto-generated部分に新しいラベルを追加
    final generatedLineList =
        (YamlEditor('')..update([], generatedLabels)).toString().split('\n');
    final modifiedLines = <String>[];
    for (final line in generatedLineList) {
      if (line.startsWith('-') && modifiedLines.isNotEmpty) {
        modifiedLines.add('');
      }
      modifiedLines.add(line.replaceAll(r'\/', '/'));
    }

    final postGeneratedContent = modifiedLines.join('\n');

    // コメント行を保持しつつ新しいYAML内容に置き換える
    final updatedContent = [
      preGeneratedContent,
      autoGeneratedLabelComment,
      postGeneratedContent,
      // NOTE: 末尾に改行を追加するために空文字を追加
      '',
    ].join('\n');

    await labelsFile.writeAsString(updatedContent);
    _logger.info('Labels updated successfully.');
    return ExitCode.success.code;
  }
}
